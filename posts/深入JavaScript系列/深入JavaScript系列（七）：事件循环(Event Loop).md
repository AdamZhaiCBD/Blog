# 一、ECMAScript中的作业和作业队列

> **作业（Job）** : 是一个抽象操作，当没有其他 ECMAScript 计算正在进行时，该操作启动 ECMAScript 计算。

> **作业队列 (Job Queues）** :作业队列是一个用来存储待处理作业的先进先出（FIFO）的队列。

这两个概念是ES6新增的，简单理解就是作业在作业队列中排队，当执行上下文栈为空时，会取出作业队列中的第一个作业进行初始化并执行计算，执行期间不会初始化其他作业，但是可能会往作业队列中添加新的待处理作业。

当前的ECMAScript规范中有两个作业队列：

1. `ScriptJobs`： 管理脚本和模块。
2. `PromiseJobs`： 管理`Promise`的回调。

ECMAScript规范中，代码执行过程基于[Runjobs()](https://www.ecma-international.org/ecma-262/9.0/index.html#sec-runjobs)操作，我们就来看看这个操作的大概内容：

1. 创建并初始化领域、领域执行上下文、全局对象。（即上篇文章中所说的领域的创建）
2. 将脚本和模块在`ScriptJobs`作业队列中排队。
3. 循环以下步骤。
    - 挂起当前执行上下文并从执行上下文栈中移除，此时执行上下文栈为空。
    - 从非空作业队列中取出最前面的一个待处理作业（即最早进入作业队列的作业）。（从哪个作业队列取作业依赖于编译器）
    - 创建新的执行上下文并推入执行上下文栈。
    - 执行作业。

# 二、事件循环是什么

**`ECMAScript`并没有从规范上约定任何异步的特性。**

> 关于Promise，我个人的理解Promise本身并不具有异步特性，而是服务于异步的。

为什么这么说呢，`ECMAScript`代码都是运行在js引擎内，js引擎都是单线程的。**单线程就意味着一旦有任何的异步特性，就避免不了线程阻塞。**

我们所探讨的**异步**（`setTimeout`、`setInterval`、DOM事件、Ajax请求等）其实都是执行`ECMAScript`代码的宿主环境（如浏览器、Node）实现的。

js引擎执行代码时遇到这些异步任务时，会将其交给其他线程处理。那么当这些任务达到触发条件（如定时器触发）时，任务的回调又是怎样确保能被js引擎执行呢？这就是我们接下来要说的实现异步能力的机制--**事件循环（Event Loop）**。我们先来看一张图，简明扼要地体现了浏览器运行机制（以Chrome为例）：

